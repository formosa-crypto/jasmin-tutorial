export
fn uninitialized() -> reg u64 {
    reg u64 x;
    x = x + 1; // Uninitialized read from x.
    return x;
}

export
fn arithmetic(reg u64 x y) -> reg u64 {
    x = x / y; // y could be zero.
    return x;
}

export
fn index(reg u64 x) -> reg u64 {
    stack u64[1] s;
    s[x] = 0; // x could be out of bounds.
    x = s[0]; // s[0] could be uninitialized
    return x;
}

export
fn termination(reg u64 n) -> reg u64 {
    reg u64 i;
    i = 0;
    while (i <= n) { // n could be 2^64-1
        i += 1;
    }
    return i;
}

export
fn alignment(reg u64 p) {
    [#aligned p] = 0; // p needs to be 64bit-aligned.
}

// Write c to the first n bytes of p.
// Run with -safetyparam 'memset>p;n'.
export
fn memset(reg u64 p, reg u8 c, reg u64 n) {
    reg u64 i;
    i = 0;
    while (i < n) {
        (u8)[p + i] = c; // 0 <= i < n
        i += 1;
    }
}
